# 5.1 Iteration

Generate tokens from lists using iteration. This is an advanced feature that creates multiple token variations based on lists or combinations of lists.

## ForEach

Generate tokens from a single list:

```tokenscript
/forEach [xs, sm, md] as size
  margin = 8
  padding = 16
```

Creates tokens:
- `xs.margin`, `xs.padding`
- `sm.margin`, `sm.padding`
- `md.margin`, `md.padding`

### With Index Keywords

Use `index`, `index0`, or `index1` to reference the current position:

```tokenscript
/forEach [xs, sm, md] as size
  value = calc($base * index)  // 1-based: 1, 2, 3
  value0 = calc($base * index0)  // 0-based: 0, 1, 2
```

**Index keywords:**
- `index` - Current position (1-based ordinal, default)
- `index0` - Current position (0-based, explicit)
- `index1` - Current position (1-based, explicit, same as `index`)

### Dynamic Collection Access

Use index in bracket selectors for dynamic access:

```tokenscript
spacing
  sp01 = 8
  sp02 = 12
  sp03 = 16
  sp04 = 20

/forEach [a, b, c] as item
  padding = $spacing[index + 1]  // a→sp02(12), b→sp03(16), c→sp04(20)
```

### Axis-Specific Values with `inEach[]`

Assign different values for each iteration position using `inEach[]`:

```tokenscript
/forEach [mobile, desktop] as device
  fontSize = inEach[14, 18]    // mobile→14, desktop→18
  padding = inEach[8, 12]      // mobile→8, desktop→12
  margin = 16                  // Same for all: 16
```

**How it works:**
- Array length must match the iteration list length
- Each value is assigned to the corresponding iteration position
- Works with numbers, strings, colors, and any value type

**Example with strings:**

```tokenscript
/forEach [heading, body, caption] as role
  fontFamily = inEach["Open Sans", "Roboto", "Inter"]
  fontSize = inEach[24, 16, 12]
  lineHeight = inEach[1.2, 1.5, 1.4]
```

**Result:**
```json
{
  "heading.fontFamily": "Open Sans",
  "heading.fontSize": 24,
  "heading.lineHeight": 1.2,
  "body.fontFamily": "Roboto",
  "body.fontSize": 16,
  "body.lineHeight": 1.5,
  "caption.fontFamily": "Inter",
  "caption.fontSize": 12,
  "caption.lineHeight": 1.4
}
```

**Error handling:**

Array length must match iteration length, or you'll get an error:

```tokenscript
/forEach [xs, sm, md] as size
  value = inEach[8, 12]    // ❌ Error: array length 2, expected 3
```

## Matrix

Create combinations from multiple lists (cartesian product):

```tokenscript
/matrix
  [primary, secondary] as color
    [light, dark] as theme
      backgroundColor = palette.{color}.{theme}
```

Creates tokens for all combinations:
- `primary.light.backgroundColor`
- `primary.dark.backgroundColor`
- `secondary.light.backgroundColor`
- `secondary.dark.backgroundColor`

### Multiple Dimensions

You can combine as many lists as needed:

```tokenscript
base = 8

deviceMultiplier
  mobile = 1
  tablet = 1.5
  desktop = 2

/matrix
  [mobile, tablet, desktop] as device
    [light, dark] as theme
      [compact, spacious] as density
        padding = calc($base * $deviceMultiplier.{device})
```

Creates 3×2×2 = 12 combinations.

### Multi-Axis Values with `inEach.axis[]`

In multi-axis matrices, specify which axis each value array applies to:

```tokenscript
/matrix
  [mobile, tablet, desktop] as device
    [light, dark] as theme
      fontSize = inEach.device[14, 16, 18]    // Different per device
      contrast = inEach.theme[1.0, 1.3]       // Different per theme
```

**Result:**
```json
{
  "mobile": {
    "light": {
      "fontSize": 14,
      "contrast": 1.0
    },
    "dark": {
      "fontSize": 14,
      "contrast": 1.3
    }
  },
  "tablet": {
    "light": {
      "fontSize": 16,
      "contrast": 1.0
    },
    "dark": {
      "fontSize": 16,
      "contrast": 1.3
    }
  },
  "desktop": {
    "light": {
      "fontSize": 18,
      "contrast": 1.0
    },
    "dark": {
      "fontSize": 18,
      "contrast": 1.3
    }
  }
}
```

**How it works:**
- `inEach.device[]` - Value broadcasts across all `device` values, constant for other axes
- `inEach.theme[]` - Value broadcasts across all `theme` values, constant for other axes
- Array length must match the specified axis length

**Single-axis shorthand:**

For single-axis matrices, you can omit the axis name:

```tokenscript
/matrix
  [button, input, select] as type
    padding = inEach[12, 8, 10]    // Shorthand: only one axis
    radius = inEach[4, 2, 3]
```

**Error: Ambiguous usage**

In multi-axis contexts, you **must** specify the axis:

```tokenscript
/matrix
  [mobile, desktop] as device
    [light, dark] as theme
      fontSize = inEach[14, 18]    // ❌ Error: Ambiguous - which axis?
      fontSize = inEach.device[14, 18]  // ✅ Correct: explicit axis
```

### Using Aliases

The `as` keyword creates an alias that can be used in:
- Token names: `palette.{color}.{theme}`
- Expressions: `calc($base.{size})`
- References: `$...{alias}.Token`

### Step Arithmetic with .scope

Use step arithmetic to navigate within scales:

```tokenscript
spacing
  sp01 = 8
  sp02 = 12
  sp03 = 16
  sp04 = 20
  sp05 = 24

/matrix [small, medium, large] as size
  base = $spacing[index + 1]              // a→sp02(12), b→sp03(16), c→sp04(20)
  next = $...base.scope[step + 1]         // Navigate within spacing scale
  prev = $...base.scope[step - 1]         // Go backward
  double = $...base.scope[step * 2]       // Jump ahead
```

**How it works:**
1. `$...base` references the token (e.g., `spacing.sp03`)
2. `.scope` extracts its collection (the `spacing` scale)
3. `[step]` gets the current position in that collection
4. `[step + 1]` navigates relative to that position

**Result:**
```
small: base=12(sp02), next=16(sp03), prev=8(sp01), double=20(sp04)
medium: base=16(sp03), next=20(sp04), prev=12(sp02), double=24(sp05)
large: base=20(sp04), next=24(sp05), prev=16(sp03), double=... (out of bounds)
```

### Rounding for Fractional Steps

When step arithmetic produces fractional positions:

```tokenscript
/matrix [a, b, c] as item
  base = $spacing[index + 1]
  half_floor = $...base.scope[step / 2]           // Default: floor
  half_ceil = $...base.scope[step / 2, up]        // Ceiling
  half_round = $...base.scope[step / 2, nearest]  // Round
```

**Rounding modes:**
- `down` or `floor` - Round down (default)
- `up` or `ceil` - Round up
- `nearest` or `round` - Round to nearest

## Combining with Conditionals

Use conditionals within iteration to create conditional token generation:

```tokenscript
/matrix [small, medium, large] as size
  /if {size} == "small"
    padding = 8
  /else if {size} == "large"
    padding = 24
  /else
    padding = 16
```

See [Conditionals](./5.2-conditionals.md) for complete conditional syntax.

## Common Use Cases

1. **Responsive breakpoints**: Generate tokens for mobile, tablet, desktop
2. **Theme variations**: Create light and dark theme tokens
3. **Size scales**: Generate xs, sm, md, lg, xl variations
4. **Color combinations**: Create all color×theme combinations
5. **Multi-dimensional systems**: Combine device×theme×density

### Real-World Example: Typography System

Combining `inEach[]` with pipelines for a complete typography system:

```tokenscript
/matrix
  [heading, body, caption] as role
    fontSizes
      /numberScale : modular
        base = inEach.role[24, 16, 12]
        peak = inEach.role[54, 20, 14]
        steps = [xs, sm, md, lg, xl]
      /roundTo(2)
    
    lineHeights
      /inherit($...fontSizes)
      /transform(value * range(inEach.role[2.1, 1.5, 1.3], inEach.role[1.1, 1.0, 1.0]))
      /roundTo(1)
    
    fontFamily = inEach.role["Open Sans", "Roboto", "Inter"]
    fontWeight
      normal = inEach.role[400, 300, 300]
      bold = inEach.role[700, 500, 400]
```

This generates:
- 3 roles × 5 font sizes = 15 font size tokens
- 3 roles × 5 line heights = 15 line height tokens  
- 3 font family tokens
- 3 roles × 2 weights = 6 weight tokens

**Total: 39 tokens** from one concise definition.

## Next Steps

- Learn about [Conditionals](./5.2-conditionals.md) for dynamic token generation
- See [References](./2.2-references.md) for step arithmetic details
- Explore [Pipelines](./4.1-pipelines.md) for transforming iterated tokens

