# 4.1 Pipelines

Apply transformations to scales and token groups using pipeline operations. Pipelines allow you to modify values and names after generation.

## Round To

Round values to nearest unit:

```tokenscript
spacing
  /numberScale : linear
    base = 7
    increment = 3
    steps = ["xs", "sm", "md"]
  /roundTo(4)
```

**Before rounding:** 7, 10, 13  
**After rounding:** 8, 12, 12

**Syntax:**
```tokenscript
/roundTo(unit, direction)
```

**Direction options:**
- `up` or `ceil` - Round up
- `down` or `floor` - Round down
- `nearest` or `round` - Round to nearest (default)

## Transform

Apply expressions to each value:

```tokenscript
spacing
  /numberScale : linear
    base = 8
    increment = 4
    steps = ["xs", "sm", "md"]
  /transform(each * 1.5)
```

**Before transform:** 8, 12, 16  
**After transform:** 12, 18, 24

### Available Variables

In transform expressions, you can use:
- `value`, `each`, `size`, `x` - Current value (all aliases)
- `index` - Current position (1-based ordinal, consistent with collection access)
- `index0` - Current position (0-based, for explicit use)
- `index1` - Current position (1-based, explicit, same as `index`)

**Examples:**
```tokenscript
/transform(value + index * 10)    // Uses ordinal: 1st→+10, 2nd→+20, 3rd→+30
/transform(value * index)         // Multiply by position: 1, 2, 3...
/transform(value + index0 * 5)    // Explicit 0-based: 0, 1, 2...
```

**Migration Note (Breaking Change):**  
In previous versions, `index` was 0-based. It is now 1-based (ordinal) for consistency with collection access (`$items[1]`, `$items[2]`). If you need 0-based indexing, use `index0` explicitly.

### Selective Transformations

Apply transformations to specific tokens using selectors. This allows fine-grained control over which tokens are transformed within a scale or inherited group.

#### Syntax

```tokenscript
/transform(expression, selector)
```

The selector is optional and defaults to `all` (transforms all tokens).

#### By Name

Transform a single token by its name:

```tokenscript
pricing
  /inherit($basePricing)
  /transform(value * 1.5, premium)
```

Only the `premium` token is multiplied by 1.5.

#### By Position Range

Transform tokens by their position (1-based ordinal):

```tokenscript
gridUnit
  /numberScale : linear
    base = 10
    steps = [gu{01..10}]
  /transform(value * 2, [1..5])
```

Doubles the first 5 items (`gu01` through `gu05`).

**Range Syntax:**
- `[1..3]` - Items 1 through 3
- `[..5]` - First 5 items (1 through 5)
- `[3..]` - From item 3 to the end
- `[-2..]` - Last 2 items
- `[1..10:2]` - Items 1, 3, 5, 7, 9 (step by 2)

#### By Name List

Transform multiple named tokens:

```tokenscript
pricing
  /inherit($basePricing)
  /transform(value * 1.2, [bob, clair])
```

Only `bob` and `clair` tokens are multiplied by 1.2.

#### By Predicate

Transform tokens based on their position:

```tokenscript
spacing
  /numberScale : linear
    base = 8
    steps = [sp{01..10}]
  /transform(value * 2, [odd])   // 1st, 3rd, 5th, 7th, 9th
  /transform(value + 5, [even])  // 2nd, 4th, 6th, 8th, 10th
```

**Available Predicates:**
- `[odd]` - Tokens at odd positions (1, 3, 5...)
- `[even]` - Tokens at even positions (2, 4, 6...)

#### Multiple Selective Transforms

Apply different transformations to different subsets:

```tokenscript
pricing
  basic = 10
  standard = 20
  premium = 30
  enterprise = 40

adjustedPricing
  /inherit($pricing)
  /transform(value * 0.8, basic)      // 20% discount
  /transform(value * 1.5, premium)    // 50% increase
  /transform(value * 2, enterprise)   // Double
```

### With `inEach[]` in Iteration

When using pipelines inside `/forEach` or `/matrix`, you can use `inEach[]` to provide different parameter values per iteration:

```tokenscript
/matrix
  [heading, body] as role
    fontSizes
      /numberScale : linear
        base = inEach.role[24, 13]     // heading: 24, body: 13
        peak = inEach.role[54, 20]     // heading: 54, body: 20
        steps = 5
      /roundTo(2)
```

This creates two separate scales with different base/peak values:
- `heading.fontSizes.*` - Scale from 24 to 54
- `body.fontSizes.*` - Scale from 13 to 20

**With transforms:**

```tokenscript
/matrix
  [mobile, desktop] as device
    spacing
      /numberScale : linear
        base = 8
        steps = [sp{01..05}]
      /transform(value * range(inEach.device[1.0, 1.5], inEach.device[1.5, 2.0]))
```

Applies different transform ranges per device:
- `mobile.spacing.*` - Multiply by 1.0 to 1.5 progression
- `desktop.spacing.*` - Multiply by 1.5 to 2.0 progression

**Why use `inEach[]` in pipelines?**
- Create variant scales with different parameters per iteration
- Apply axis-specific transformations
- Maintain DRY principles - define the scale structure once, vary the parameters

## Rename

Rename tokens using template expressions. This allows you to transform token names dynamically based on their original name or position.

### Syntax

```tokenscript
/rename("template", [selector])
```

The template is a quoted string (single or double quotes) that can contain:
- `{name}` - The original token name
- `{index}` - The token's position (1-based ordinal)
- `{index0}` - The token's position (0-based, explicit)
- `{index1}` - The token's position (1-based, explicit, same as `{index}`)
- `{expression}` - Math expressions evaluated with `index`, `index0`, `index1` variables

The selector is optional and defaults to `all` (renames all tokens).

### Basic Usage

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 2
    steps = [gu{01..03}]
  /rename("spacing-{index}")
```

Creates: `spacing-1`, `spacing-2`, `spacing-3`

### Using {name}

Include the original token name in the new name:

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 2
    steps = [gu{01..03}]
  /rename("my-{name}")
```

Creates: `my-gu01`, `my-gu02`, `my-gu03`

### Using Math Expressions

Evaluate expressions in the template:

```tokenscript
colors
  /numberScale : linear
    base = 100
    increment = 50
    steps = [c{01..03}]
  /rename("color-{index * 100}")
```

Creates: `color-100`, `color-200`, `color-300`

### Padding Numbers

Pad indices directly in the template (leading zeros by default):

```tokenscript
spacing
  /numberScale : linear
    base = 8
    increment = 8
    steps = [sp{01..03}]
  /rename("sz{index.pad(2)}")
```

Creates: `sz01`, `sz02`, `sz03`

Do math first, then pad:

```tokenscript
/rename("sz{(index * 2).pad(3)}")  // sz002, sz004, ...
```

Notes:
- `pad(width)` keeps the original value if it’s already that wide
- Optional third argument sets the pad character: `index.pad(3, "_")`
- You don’t need `calc()` inside templates—`{ }` already supports expressions
- When the outer template uses double quotes, wrap the pad character in single quotes: `/rename("sz{index.pad(3, '_')}")`

### With Selector

Rename only specific tokens:

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 2
    steps = [gu{01..05}]
  /rename("spacing-{index}", [1..3])
```

Only the first 3 tokens are renamed.

### With Inherit

Rename inherited tokens:

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 2
    steps = [gu{01..03}]

spacing
  /inherit($gridUnit)
  /rename("sp-{index}")
```

### String Functions (Method Chaining)

Use string manipulation functions to transform token names. Functions can be chained together using dot notation.

**Available Functions:**
- `find(pattern)` - Finds all occurrences of a pattern in the name (establishes scope for subsequent operations)
- `replace(old, new)` - Replaces patterns (works standalone on whole name, or after `find()` on found parts)
- `case(mode)` - Transforms case (works standalone on whole name, or after `find()` on found parts)
- `remove(pattern)` - Removes patterns (works standalone with pattern argument, or after `find()` without argument)

**Scope Rules:**
- `find()` establishes scope - all subsequent operations in the chain operate on found parts only
- Without `find()`, operations operate on the whole name sequentially
- Scope persists through the entire chain after `find()`

#### replace() Standalone

Replace patterns in the whole name:

```tokenscript
colors
  color-dark = #000
  bg-dark-blue = #1e3a8a
  /rename(replace('dark', 'light'))
```

#### find().replace()

Find and replace patterns within found parts:

```tokenscript
colors
  color-dark = #000
  bg-dark-blue = #1e3a8a
  /rename(find('dark').replace('dark', 'light'))
```

#### find().case()

Transform only the found parts:

```tokenscript
colors
  color-dark = #000
  bg-dark-blue = #1e3a8a
  /rename(find('dark').case('uppercase'))
```

#### find().remove()

Remove found patterns:

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 2
    steps = [gu{01..03}]
  /rename(find('gu').remove())
```

#### case() and remove() Standalone

These functions can also work on the whole name without `find()`:

```tokenscript
tokens
  gridUnit = 8
  spacingUnit = 16
  /rename(case('kebabcase'))
```

```tokenscript
legacyTokens
  old-grid-unit = 8
  old-spacing-unit = 16
  /rename(remove('old-'))
```

#### Method Chaining

Chain multiple operations together:

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 2
    steps = [gu{01..03}]
  /rename(find('gu').replace('gu', 'sp').case('uppercase'))
```

**Available case modes:**
- `uppercase` - UPPERCASE
- `lowercase` - lowercase
- `titlecase` - Title Case
- `camelcase` - camelCase
- `kebabcase` - kebab-case
- `snakecase` - snake_case

### Combining with Other Pipeline Operations

Rename can be combined with transform and roundTo:

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 2
    steps = [gu{01..03}]
  /rename("spacing-{index}")
  /transform(*2)
  /roundTo(1)
```

### Selector Syntax

The selector uses the same syntax as selective transformations:
- `[1..3]` - Range of positions
- `[2..+5]` - Count-based slice (start at 2, take 5 items)
- `[..5]` - First 5 items
- `[3..]` - From position 3 to end
- `[odd]` - Odd positions
- `[even]` - Even positions
- `[bob, clair]` - List of names
- `premium` - Single name

**Examples:**
```tokenscript
/rename("color-{index}", [1..3])        // Rename first 3
/rename("size-{name}", [odd])           // Rename odd positions
/rename("premium-{name}", premium)      // Rename single token
```

### Common Use Cases

1. **Tiered Pricing**: Apply different multipliers to different price tiers
2. **Responsive Adjustments**: Scale specific breakpoint values differently
3. **Progressive Enhancement**: Apply transformations to later items in a sequence
4. **Alternating Patterns**: Use `[odd]` and `[even]` for alternating effects

**Notes:**
- Selectors work with both scales and inherited groups
- Token names are matched exactly (case-sensitive)
- Non-matching selectors are silently ignored (no error)
- Positions use 1-based ordinal indexing (consistent with collection access)
- Multiple transforms are applied in order

## Reference (Block-Level)

The `/reference()` pipeline operation matches token values to tokens in a specified scope. This is a block-level operation that runs after all tokens in a scale or group are generated.

**Syntax:**
```tokenscript
/reference(scope, direction)
```

**Direction options:**
- `nearest` - Find closest value (default)
- `up` or `ceil` - Find next higher value
- `down` or `floor` - Find next lower value

**Example:**
```tokenscript
derivedValues
  /inherit($sourceScale)
  /transform(value * 1.5)
  /reference(spacing, up)  // Match each value to spacing scale
```

This ensures all generated values reference existing tokens in the `spacing` scope when possible.

## Next Steps

- Learn about [Selectors](./4.2-selectors.md) for fine-grained targeting
- Explore [Iteration](./5.1-iteration.md) for generating tokens from lists
- See [Number Scales](./3.1-number-scales.md) for scale generation
