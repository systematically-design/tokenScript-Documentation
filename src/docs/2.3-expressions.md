# 2.3 Expressions

Learn how to perform calculations, chain operations, and work with dynamic values in TokenScript.

## calc() for Arithmetic

Arithmetic expressions must use the `calc()` wrapper for clarity and explicitness:

```tokenscript
base = 8
double = calc($base * 2)
half = calc($base / 2)
sum = calc($base + 4)
difference = calc($base - 2)
```

**Why calc()?** It makes calculations explicit and eliminates ambiguity. Without `calc()`, expressions like `value = 4 + 5` would cause an error guiding you to use `calc(4 + 5)`.

**Supported operators:** `+`, `-`, `*`, `/`, `%` (modulo)

**Simple references don't need calc():**
```tokenscript
value = $base        // OK - no arithmetic
```

## Method Chaining

Chain methods for post-processing calculations:

### Rounding

```tokenscript
rounded = calc(100 / 3).roundTo(1)                    // → 33
roundUp = calc(127.5).roundTo(10, up)                 // → 130
roundDown = calc(127.5).roundTo(10, down)             // → 120
roundNearest = calc(127.5).roundTo(10, nearest)       // → 130
```

**Rounding modes:**
- `up` or `ceil` - Round up
- `down` or `floor` - Round down
- `nearest` or `round` - Round to nearest

### Reference Lookup

```tokenscript
spacing
  sp01 = 10
  sp02 = 20
  sp03 = 30

test
  nearest = calc(25).reference(spacing, nearest)      // → 30 (sp03)
  up = calc(25).reference(spacing, up)                // → 30 (sp03)
  down = calc(25).reference(spacing, down)            // → 20 (sp02)
```

**Reference modes:**
- `nearest` - Find closest value
- `up` or `ceil` - Find next higher value
- `down` or `floor` - Find next lower value

### Chaining Multiple Operations

```tokenscript
// Chain multiple operations
value = calc($base * 2.7).roundTo(4, up).reference(spacing, nearest)
```

## Scope Persistence

When an expression references a token from a specific scope and performs calculations, the scope context persists. The system automatically searches that same scope for a matching token:

```tokenscript
spacing
  sp01 = 10
  sp02 = 20
  sp03 = 30
  sp04 = 40

derived
  // References $spacing.sp02 (20), doubles it to 40
  // Automatically finds and references sp04 (40)
  double = calc($spacing.sp02 * 2)  // → 40, ref: "spacing.sp04"
  
  // References $spacing.sp04 (40), halves it to 20
  // Automatically finds and references sp02 (20)
  half = calc($spacing.sp04 / 2)    // → 20, ref: "spacing.sp02"
```

**How it works:**
1. Expression starts with a token reference (e.g., `$spacing.sp02`)
2. Calculation is performed (e.g., `* 2` → `40`)
3. System searches the source scope (`spacing`) for a token with value `40`
4. If found, the result includes a `ref` property pointing to that token

**Benefits:**
- Maintains semantic relationships between tokens
- Enables design system consistency
- Allows tooling to understand token relationships

**When scope persistence happens:**
- Expression starts with `$nameScope.token`
- No explicit `.reference()` method is used
- Result value exactly matches another token in the same scope

**When it doesn't:**
- Expression doesn't start with a token reference
- Explicit `.reference()` is used (takes precedence)
- No exact match exists in the source scope

## Interpolation

You can interpolate expressions using `{expr}`:

```tokenscript
fullName = { $firstName + " " + $lastName }
fontSize = $...fontSizes.{role}
label    = "Hello { $firstName } { $lastName }"
```

**Inside `{...}` you can use:**
- Iterator variables (e.g. `role`, `weight`)
- `$` references (e.g. `$token`, `$...fontSizes.{role}`)
- Basic arithmetic with `expr-eval` semantics

### Template Strings

Combine interpolation with string literals:

```tokenscript
button
  label = "Click { $action }"
  className = "btn-{ $variant }"
```

## Next Steps

- Explore [Composite Tokens](./2.4-composite-tokens.md) for complex structured values
- Learn about [Number Scales](./3.1-number-scales.md) for parametric generation
- See [Pipelines](./4.1-pipelines.md) for transforming token collections

