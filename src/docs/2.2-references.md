# 2.2 References

Learn how to reference and reuse token values throughout your design system.

## Dollar References

Reference other tokens using `$`:

```tokenscript
baseSpacing = 8
cardPadding = $baseSpacing
buttonPadding = calc($baseSpacing * 2)
```

**Note:** Simple references like `$baseSpacing` don't need `calc()`, but arithmetic expressions like `$baseSpacing * 2` must use `calc()`.

### Nested References

```tokenscript
colors
  primary = #3B82F6

button
  backgroundColor = $colors.primary
```

### Self References (Ellipsis)

Use `$...` to reference within the current scope:

```tokenscript
spacing
  /numberScale : linear
    base = 8
    increment = 4
    steps = ["xs", "sm", "md"]
  // Reference the base from this scale
  custom = calc($...base * 3)
```

The `$...` syntax searches upward through parent scopes to find the referenced token.

## Collection Access

Access items from arrays and scales using bracket notation with 1-based ordinal indexing:

### Single Items

```tokenscript
sizes = ["xs", "sm", "md", "lg", "xl"]

first = $sizes[1]        // "xs"
third = $sizes[3]        // "md"
last = $sizes[-1]        // "xl"
secondLast = $sizes[-2]  // "lg"
```

### Named Positions

```tokenscript
firstItem = $sizes[first]   // "xs"
lastItem = $sizes[last]     // "xl"
secondItem = $sizes[second] // "sm"
thirdItem = $sizes[third]   // "md"
```

### Ranges

```tokenscript
subset = $sizes[2..4]     // ["sm", "md", "lg"]
firstThree = $sizes[..3]  // ["xs", "sm", "md"]
lastTwo = $sizes[-2..]    // ["lg", "xl"]
positionsTwoThroughTen = $sizes[2..10] // Standard range (inclusive)
all = $sizes[1..]         // All items

// With step
every2nd = $sizes[1..5:2]   // ["xs", "md", "xl"]
oddPos = $sizes[1..5:2]     // Same: 1st, 3rd, 5th

// With count-based slice
threeFromSecond = $sizes[2..+3]     // 3 items starting at position 2 → ["sm", "md", "lg"]
everyOtherThree = $sizes[2..+3:2]   // 3 items starting at position 2, step 2 → positions 2,4,6
tenFromSecond = $sizes[2..+10]      // 10 items starting at position 2 (clamped if fewer available)
```

### Predicates

```tokenscript
oddItems = $sizes[odd]      // ["xs", "md", "xl"]
evenItems = $sizes[even]    // ["sm", "lg"]
```

### List Unions

```tokenscript
selected = $sizes[1, 3, 5]  // ["xs", "md", "xl"]
mixed = $sizes[1..2, 5]     // ["xs", "sm", "xl"]
```

**Important rules:**
- All indexing is **1-based** (ordinal): `$items[1]` is the first item
- `$items[0]` is an **error**: "Index 0 is invalid, ordinals start at 1"
- Ranges are **inclusive**: `[2..4]` includes positions 2, 3, and 4
- Single-index access is **strict** (errors if out of bounds)
- Range access is **safe** (clamped to valid bounds, no error)
- Negative ordinals count from end: `-1` is last, `-2` is second from last

### Getting Keys Instead of Values

Use `.key` to get the token name/key instead of its value:

```tokenscript
gridUnit
  /numberScale : linear
    base = 8
    increment = 4
    steps = [gu{01..05}]

// Get values (default)
value = $gridUnit[second]        // 12

// Get keys (use .key)
name = $gridUnit[second].key     // "gu03"

// Works with ranges
values = $gridUnit[1..3]         // [8, 12, 16]
names = $gridUnit[1..3].key      // ["gu01", "gu02", "gu03"]

// Works with predicates
oddValues = $gridUnit[odd]       // [8, 16, 24]
oddKeys = $gridUnit[odd].key     // ["gu01", "gu03", "gu05"]
```

**Note:** `.key` only works with scale/group references, not plain arrays.

### Using Ellipsis References with Collection Access

Ellipsis references (`$...ref`) can be combined with bracket notation to access collections from parent scopes:

```tokenscript
parent
  sizes = ["xs", "sm", "md", "lg", "xl"]
  gridUnit
    /numberScale : linear
      base = 10
      increment = 5
      steps = [gu{01..04}]
  
  nested
    // Access array from parent scope
    firstSize = $...sizes[first]      // "xs"
    lastTwo = $...sizes[-2..]         // ["lg", "xl"]
    middle = $...sizes[2..4]          // ["sm", "md", "lg"]
    
    // Access scale from parent scope
    values = $...gridUnit[1..3]       // [10, 15, 20]
    keys = $...gridUnit[1..3].key     // ["gu01", "gu02", "gu03"]
```

## Arithmetic in Bracket Selectors

You can use arithmetic expressions inside bracket selectors for dynamic indexing:

```tokenscript
spacing
  sp01 = 10
  sp02 = 20
  sp03 = 30
  sp04 = 40

test
  // Numeric arithmetic
  simple = $spacing[2 + 1]           // → 30 (index 3)
  doubled = $spacing[2 * 2]          // → 40 (index 4)
  
  // With iterator variables (in /forEach or /matrix)
  /matrix
    [a, b, c] as item
      value = $spacing[index + 1]    // Dynamic: a→sp02, b→sp03, c→sp04
```

**Operators supported:** `+`, `-`, `*`, `/`

**Note:** Arithmetic inside brackets does NOT require `calc()` - the bracket context makes intent clear.

## Step-Based Navigation with .scope

Access a token's collection using `.scope`, then navigate by step:

```tokenscript
spacing
  sp01 = 8
  sp02 = 12
  sp03 = 16
  sp04 = 20
  sp05 = 24

test
  /matrix
    [small, medium, large] as size
      base = $spacing[index + 1]              // a→sp02(12), b→sp03(16), c→sp04(20)
      next = $...base.scope[step + 1]         // Navigate within spacing scale
      prev = $...base.scope[step - 1]         // Go backward
      double = $...base.scope[step * 2]       // Jump ahead
```

**How it works:**
1. `$...base` references the token (e.g., `spacing.sp03`)
2. `.scope` extracts its collection (the `spacing` scale)
3. `[step]` gets the current position in that collection
4. `[step + 1]` navigates relative to that position

### Rounding Modes in Selectors

When arithmetic produces fractional positions, specify rounding with a second argument:

```tokenscript
spacing
  sp01 = 8
  sp02 = 12
  sp03 = 16
  sp04 = 20

test
  /matrix
    [a, b, c] as item
      base = $spacing[index + 1]
      half_floor = $...base.scope[step / 2]           // Default: floor
      half_ceil = $...base.scope[step / 2, up]        // Ceiling
      half_round = $...base.scope[step / 2, nearest]  // Round
```

**Rounding modes:**
- `down` or `floor` - Round down (default)
- `up` or `ceil` - Round up
- `nearest` or `round` - Round to nearest

## Next Steps

- Learn about [Expressions](./2.3-expressions.md) for calculations and method chaining
- Explore [Number Scales](./3.1-number-scales.md) to create parametric value systems
- See [Iteration](./5.1-iteration.md) for generating tokens from lists
