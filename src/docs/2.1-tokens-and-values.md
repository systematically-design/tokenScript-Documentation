# 2.1 Tokens & Values

Learn the fundamentals of TokenScript DSL syntax - how to define tokens, work with different value types, and organize your design system.

## Basic Syntax

Tokens are defined using simple `name = value` syntax:

```tokenscript
spacing = 16
primary = #3B82F6
fontFamily = "Inter, sans-serif"
```

### Nesting

Group related tokens using indentation:

```tokenscript
colors
  primary = #3B82F6
  secondary = #8B5CF6
  
spacing
  sm = 8
  md = 16
  lg = 24
```

**Output:**
```json
{
  "colors.primary": "#3B82F6",
  "colors.secondary": "#8B5CF6",
  "spacing.sm": 8,
  "spacing.md": 16,
  "spacing.lg": 24
}
```

### Comments

Use `//` for single-line comments:

```tokenscript
// Base spacing unit
baseUnit = 8

spacing
  sm = 8  // Small spacing
  md = 16 // Medium spacing
```

Multi-line comments use `/* */`:

```tokenscript
/*
 * Brand color palette
 * Updated: 2024-01-01
 */
colors
  primary = #3B82F6
```

## Value Types

TokenScript automatically infers types from your values:

### Numbers

```tokenscript
spacing = 16
opacity = 0.5
fontSize = 14.5
```

### Strings

```tokenscript
fontFamily = "Inter, sans-serif"
label = "Click me"
```

### Booleans

```tokenscript
enabled = true
visible = false
```

### Colors

Multiple color formats supported:

**Hex:**
```tokenscript
primary = #3B82F6
accent = #f00           // Short hex
overlay = #3B82F680     // With alpha
```

**RGB/RGBA:**
```tokenscript
primary = rgb(59, 130, 246)
overlay = rgba(59, 130, 246, 0.5)
```

**HSL/HSLA:**
```tokenscript
primary = hsl(217, 91%, 60%)
overlay = hsla(217, 91%, 60%, 0.5)
```

**OKLCH:**
```tokenscript
primary = oklch(0.65, 0.2, 250)  // Perceptually uniform
```

**Named Colors:**
```tokenscript
primary = blue
background = white
text = black
```

## Type System

### Automatic Type Inference

TokenScript automatically detects data types:

```tokenscript
count = 42          // → number
name = "Token"      // → string  
active = true       // → boolean
  brand = #FF0000     // → color
```

No annotations needed - types are inferred from values.

## Type System

### Scope Annotation

Annotate tokens with semantic scope information:```tokenscript
spacing
  md = 16
    scope = spacing

colors
  primary = #3B82F6
    scope = brand

borderRadius
  sm = 4
    scope = radius
```

Scope allows you to categorize tokens semantically (spacing, sizing, brand, etc.) for better organization and tooling support.

## Type Annotations

Explicitly annotate tokens with their expected type for validation and clarity:

```tokenscript
spacing : number = 16
primary : color = #3B82F6
fontFamily : string = "Inter, sans-serif"
enabled : boolean = true
```

### Supported Primitive Types

- **`number`** - Numeric values: `16`, `0.5`, `-4`
- **`color`** - Color values in any format: `#3B82F6`, `rgb(59, 130, 246)`, `blue`
- **`string`** - Text values: `"Inter, sans-serif"`, `"medium"`
- **`boolean`** - True/false: `true`, `false`

### Type Validation

When you annotate a type, the system validates that assigned values match:

```tokenscript
fontSize : number = 14      // ✓ Valid
fontSize : number = "14px"  // ✗ Error: string assigned to number type

brand : color = #3B82F6     // ✓ Valid
brand : color = 255         // ✗ Error: number assigned to color type
```

Error messages guide you with suggestions:
```
Type mismatch: expected 'number', got 'string'
  Did you mean to wrap with quotes removed? "14px" → 14
```

### Type Annotations in Nested Tokens

Type annotations work seamlessly with nested structures:

```tokenscript
colors
  primary : color = #3B82F6
  secondary : color = #8B5CF6
  opacity : number = 0.8
  
spacing
  base : number = 8
  compact : number = 4
  comfortable : number = 16
```

### Type Annotations on Groups

You can annotate a group/collection to apply type constraints to all values within it:

```tokenscript
sizes : number
  sm = 8
  md = 16
  lg = 24
  xl = 32
```

This is equivalent to annotating each token individually:

```tokenscript
sizes
  sm : number = 8
  md : number = 16
  lg : number = 24
  xl : number = 32
```

### Shorthand Syntax

When the name matches the type, you can use shorthand notation with just the colon:

```tokenscript
:spacing                 // Same as: spacing : spacing
  sm = 8
  md = 16
  lg = 24
  xl = 32

:typeSizes               // Same as: typeSizes : typeSizes
  small = 12
  medium = 16
  large = 20
  xlarge = 24
```

This shorthand is useful when the token name and type name are identical, avoiding repetition.

## Composite Types

For tokens representing complex, multi-property values, use composite type annotations:

```tokenscript
button : typography
  fontFamily = "Inter"
  fontSize = 16
  fontWeight = 600
  lineHeight = 1.5
  letterSpacing = 0.5

shadow : shadow
  color = #000000
  offsetX = 0
  offsetY = 4
  blur = 12
  spread = 0
```

### Supported Composite Types

#### Typography
Typography tokens represent font-related properties:

```tokenscript
heading : typography
  fontFamily = "Inter, sans-serif"     // Required
  fontSize = 32                        // Required
  fontWeight = 700                     // Required
  lineHeight = 1.2                     // Required
  letterSpacing = -0.5                 // Required
  textDecoration = "none"              // Optional
  textTransform = "none"               // Optional
  fontStyle = "normal"                 // Optional
  textCase = "none"                    // Optional
  textIndent = 0                       // Optional
  paragraphSpacing = 0                 // Optional
```

**Use for:** Font definitions, text styles, heading styles, display text

#### Shadow
Shadow tokens represent drop shadow or box-shadow effects:

```tokenscript
elevation : shadow
  color = #000000                      // Required
  offsetX = 0                          // Required
  offsetY = 4                          // Required
  blur = 12                            // Required
  spread = 0                           // Required
  inset = false                        // Optional
```

**Use for:** Shadows, elevation systems, depth effects, drop shadows

#### Border
Border tokens represent stroke or border styles:

```tokenscript
divider : border
  color = #E5E7EB                      // Required
  width = 1                            // Required
  style = "solid"                      // Required (solid, dashed, dotted, double, etc.)
```

**Use for:** Dividers, strokes, outline definitions, borders

#### Transition
Transition tokens represent animation timing and duration:

```tokenscript
smooth : transition
  duration = 300                       // Required (milliseconds)
  delay = 0                            // Required (milliseconds)
  timingFunction = "ease-in-out"       // Required (cubic-bezier, ease-in-out, linear, etc.)
```

**Use for:** Animation definitions, motion timing, transitions, durations

### Composite Type Validation

Each composite type enforces its structure. Required properties must be present:

```tokenscript
button : typography
  fontFamily = "Inter"
  fontSize = 16
  // ✗ Error: Missing required properties: fontWeight, lineHeight, letterSpacing

button : typography
  fontFamily = "Inter"
  fontSize = 16
  fontWeight = 600
  lineHeight = 1.5
  letterSpacing = 0        // ✓ All required properties provided
  textTransform = "uppercase"  // ✓ Optional property also valid
```

### Accessing Composite Type Properties

Reference individual properties using dot notation:

```tokenscript
button : typography
  fontFamily = "Inter"
  fontSize = 32
  fontWeight = 700
  lineHeight = 1.2
  letterSpacing = -0.5

// In expressions or other tokens:
largeHeading
  font = $button.fontFamily    // "Inter"
  size = $button.fontSize      // 32
```

### Best Practices

1. **Use type annotations for intent clarity** - Even though types are inferred, annotations document expected types
2. **Composite types for semantic values** - Use `typography`, `shadow`, `border`, `transition` for structured data
3. **Organize by type** - Group related composite tokens:
   ```tokenscript
   typography
     heading : typography
       ...
     body : typography
       ...
   
   shadows
     sm : shadow
       ...
     lg : shadow
       ...
   ```

## Next Steps

- Learn about [References](./2.2-references.md) to reuse token values
- Explore [Expressions](./2.3-expressions.md) for calculations
- See [Composite Tokens](./2.4-composite-tokens.md) for complex values

